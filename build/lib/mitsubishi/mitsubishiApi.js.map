{
  "version": 3,
  "sources": ["../../../src/lib/mitsubishi/mitsubishiApi.ts"],
  "sourcesContent": ["// src/mitsubishi/mitsubishiApi.ts\nimport type { AxiosInstance } from \"axios\";\nimport axios from \"axios\";\nimport * as crypto from \"crypto\";\nimport { KEY_SIZE, STATIC_KEY } from \"./types\";\nimport { padIso7816, unpadIso7816 } from \"./utils\";\n\nexport class MitsubishiAPI {\n\tprivate log: ioBroker.Logger;\n\tprivate deviceHostPort: string;\n\tprivate encryptionKey: Buffer;\n\tprivate http: AxiosInstance;\n\n\tconstructor(deviceHostPort: string, log: ioBroker.Logger, encryptionKey: string | Buffer = STATIC_KEY) {\n\t\tthis.deviceHostPort = deviceHostPort;\n\t\tthis.log = log;\n\t\tif (typeof encryptionKey === \"string\") {\n\t\t\tencryptionKey = Buffer.from(encryptionKey, \"utf8\");\n\t\t}\n\t\tif (encryptionKey.length < KEY_SIZE) {\n\t\t\tencryptionKey = Buffer.concat([encryptionKey, Buffer.alloc(KEY_SIZE - encryptionKey.length, 0x00)]);\n\t\t}\n\t\tthis.encryptionKey = encryptionKey.subarray(0, KEY_SIZE);\n\n\t\t// Axios instance; note Python used requests.Session() + Retry adapter.\n\t\t// We'll implement retries in make_request similarly.\n\t\tthis.http = axios.create({\n\t\t\ttimeout: 2000,\n\t\t\theaders: {\n\t\t\t\t\"User-Agent\":\n\t\t\t\t\t\"KirigamineRemote/5.1.0 (jp.co.MitsubishiElectric.KirigamineRemote; build:3; iOS 17.5.1) Alamofire/5.9.1\",\n\t\t\t},\n\t\t\t// do not automatically throw for non-2xx; we will call resp.status/raise manually\n\t\t\tvalidateStatus: () => true,\n\t\t});\n\t}\n\n\tgetCryptoKey(): Buffer {\n\t\treturn this.encryptionKey;\n\t}\n\n\tgetDeviceHostPort(): string {\n\t\treturn this.deviceHostPort;\n\t}\n\n\t/**\n\t * Encrypt payload using AES-CBC with ISO7816-4 padding\n\t * Returns base64(iv + ciphertext)\n\t */\n\tencryptPayload(payload: string, iv?: Buffer): string {\n\t\tif (!iv) {\n\t\t\tiv = crypto.randomBytes(KEY_SIZE);\n\t\t}\n\t\tconst cipher = crypto.createCipheriv(\"aes-128-cbc\", this.encryptionKey, iv);\n\t\tcipher.setAutoPadding(false);\n\n\t\tconst payloadBytes = Buffer.from(payload, \"utf8\");\n\t\tconst padded = padIso7816(payloadBytes, KEY_SIZE);\n\n\t\tconst encrypted = Buffer.concat([cipher.update(padded), cipher.final()]);\n\n\t\tconst combined = Buffer.concat([iv, encrypted]);\n\t\treturn combined.toString(\"base64\");\n\t}\n\n\t/**\n\t * Decrypt base64(iv + ciphertext) using AES-CBC + ISO7816 unpad fallback.\n\t * Mirrors Python behaviour: try iso7816 unpad; on failure strip trailing \\x00;\n\t * then try to decode UTF-8; on UnicodeDecodeError search for closing tags and fallback to ignore errors.\n\t */\n\tdecryptPayload(payload_b64: string): string {\n\t\t// base64 -> bytes\n\t\tconst encrypted = Buffer.from(payload_b64, \"base64\"); // may throw\n\n\t\t// Extract IV and encrypted_data\n\t\tconst iv = encrypted.subarray(0, KEY_SIZE);\n\t\tconst encrypted_data = encrypted.subarray(KEY_SIZE);\n\n\t\t// AES-CBC decrypt\n\t\tconst decipher = crypto.createDecipheriv(\"aes-128-cbc\", this.encryptionKey, iv);\n\t\tdecipher.setAutoPadding(false);\n\t\tlet decrypted: Buffer;\n\t\ttry {\n\t\t\tdecrypted = Buffer.concat([decipher.update(encrypted_data), decipher.final()]);\n\t\t} catch (e) {\n\t\t\t// Propagate error similar to Python (will be caught higher-level)\n\t\t\tthrow new Error(`Decryption failed: ${(e as Error).message}`);\n\t\t}\n\n\t\t// Try ISO7816 unpad\n\t\tlet decrypted_clean: Buffer;\n\t\ttry {\n\t\t\tdecrypted_clean = unpadIso7816(decrypted);\n\t\t} catch {\n\t\t\t// fallback: remove trailing 0x00\n\t\t\tlet end = decrypted.length;\n\t\t\twhile (end > 0 && decrypted[end - 1] === 0x00) {\n\t\t\t\tend--;\n\t\t\t}\n\t\t\tdecrypted_clean = decrypted.subarray(0, end);\n\t\t}\n\n\t\t// Try to decode as UTF-8\n\t\ttry {\n\t\t\tconst result = decrypted_clean.toString(\"utf8\");\n\t\t\treturn result;\n\t\t} catch {\n\t\t\t// Node's Buffer.toString won't throw UnicodeDecodeError like Python; but we'll follow fallback logic.\n\t\t\t// Attempt to find closing tags in raw bytes, then decode slice.\n\t\t}\n\n\t\t// Try to find closing XML tags like Python did\n\t\tconst xml_end_patterns = [Buffer.from(\"</LSV>\"), Buffer.from(\"</CSV>\"), Buffer.from(\"</ESV>\")];\n\t\tfor (const pattern of xml_end_patterns) {\n\t\t\tconst pos = decrypted_clean.indexOf(pattern);\n\t\t\tif (pos !== -1) {\n\t\t\t\tconst end_pos = pos + pattern.length;\n\t\t\t\tconst truncated = decrypted_clean.subarray(0, end_pos);\n\t\t\t\ttry {\n\t\t\t\t\treturn truncated.toString(\"utf8\");\n\t\t\t\t} catch {\n\t\t\t\t\t// continue\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Last resort: decode ignoring errors (in Node Buffer.toString does not have errors='ignore' param,\n\t\t// but replacing invalid sequences is default behaviour; to mimic 'ignore' we can remove replacement characters)\n\t\t// We'll return decoded string (replacement characters may appear).\n\t\tconst fallback_result = decrypted_clean.toString(\"utf8\");\n\t\treturn fallback_result;\n\t}\n\n\t/**\n\t * Make HTTP request to /smart endpoint.\n\t * Mirrors Python's make_request: encrypt payload, wrap in <ESV>..</ESV>, POST, parse response, decrypt.\n\t */\n\tasync makeRequest(payload_xml: string): Promise<string> {\n\t\t// Encrypt\n\t\tconst encrypted_payload = this.encryptPayload(payload_xml);\n\n\t\t// Build request body (exact same string shape)\n\t\tconst request_body = `<?xml version=\"1.0\" encoding=\"UTF-8\"?><ESV>${encrypted_payload}</ESV>`;\n\n\t\tconst headers = {\n\t\t\tHost: `${this.deviceHostPort}`,\n\t\t\t\"Content-Type\": \"text/plain;chrset=UTF-8\",\n\t\t\tConnection: \"keep-alive\",\n\t\t\t\"Proxy-Connection\": \"keep-alive\",\n\t\t\tAccept: \"*/*\",\n\t\t\t\"User-Agent\":\n\t\t\t\t\"KirigamineRemote/5.1.0 (jp.co.MitsubishiElectric.KirigamineRemote; build:3; iOS 17.5.1) Alamofire/5.9.1\",\n\t\t\t\"Accept-Language\": \"zh-Hant-JP;q=1.0, ja-JP;q=0.9\",\n\t\t};\n\n\t\tconst url = `http://${this.deviceHostPort}/smart`;\n\n\t\t// retry logic: total=4, backoff_factor=1 (attempts 0..4)\n\t\tconst maxRetries = 4;\n\t\tlet lastErr: any = null;\n\t\tfor (let attempt = 0; attempt <= maxRetries; attempt++) {\n\t\t\ttry {\n\t\t\t\tconst resp = await this.http.post(url, request_body, { headers, timeout: 2000 });\n\t\t\t\t// emulate response.raise_for_status()\n\t\t\t\tif (resp.status < 200 || resp.status >= 300) {\n\t\t\t\t\tconst e = new Error(`HTTP Error ${resp.status}`);\n\t\t\t\t\t(e as any).status = resp.status;\n\t\t\t\t\t(e as any).body = resp.data;\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\n\t\t\t\t// Parse XML root and get root.text like ElementTree.fromstring(...).text\n\t\t\t\t// Python: root = ET.fromstring(response.text); encrypted_response = root.text\n\t\t\t\t// Here extract inner text between the outermost tag, e.g. <ESV>...</ESV>\n\t\t\t\tconst m = String(resp.data).match(/<ESV>\\s*([^<]+)\\s*<\\/ESV>/i);\n\t\t\t\tconst encrypted_response = m?.[1];\n\n\t\t\t\tif (encrypted_response) {\n\t\t\t\t\tif (encrypted_response.length % 4 !== 0) {\n\t\t\t\t\t\tthis.log.error(`Invalid base64 length: ${encrypted_response.length}`);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst decrypted = this.decryptPayload(encrypted_response);\n\t\t\t\t\treturn decrypted;\n\t\t\t\t}\n\t\t\t\tthrow new Error(\"Could not find any text in response\");\n\t\t\t} catch (err) {\n\t\t\t\tlastErr = err;\n\t\t\t\tif (attempt < maxRetries) {\n\t\t\t\t\tconst wait = 1000 * Math.pow(2, attempt); // backoff_factor=1 -> 1s,2s,4s...\n\t\t\t\t\tawait new Promise(r => setTimeout(r, wait));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tthrow lastErr;\n\t\t\t}\n\t\t}\n\t\tthrow lastErr;\n\t}\n\n\tsendRebootRequest(): Promise<string> {\n\t\treturn this.makeRequest(\"<CSV><RESET></RESET></CSV>\");\n\t}\n\n\tsendStatusRequest(): Promise<string> {\n\t\treturn this.makeRequest(\"<CSV><CONNECT>ON</CONNECT></CSV>\");\n\t}\n\n\tsendEchonetEnable(): Promise<string> {\n\t\treturn this.makeRequest(\"<CSV><CONNECT>ON</CONNECT><ECHONET>ON</ECHONET></CSV>\");\n\t}\n\n\tsendCommand(command: Buffer | Uint8Array): Promise<string> {\n\t\tconst hex = Buffer.isBuffer(command) ? command.toString(\"hex\") : Buffer.from(command).toString(\"hex\");\n\t\treturn this.sendHexCommand(hex);\n\t}\n\n\tsendHexCommand(hexCommand: string): Promise<string> {\n\t\tconst payload = `<CSV><CONNECT>ON</CONNECT><CODE><VALUE>${hexCommand}</VALUE></CODE></CSV>`;\n\t\treturn this.makeRequest(payload);\n\t}\n\n\tclose(): void {\n\t\t// nothing to close; keep for API parity\n\t\t(this.http as any) = null;\n\t}\n}\n"],
  "mappings": "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",
  "names": ["axios"]
}
