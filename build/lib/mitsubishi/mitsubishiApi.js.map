{
  "version": 3,
  "sources": ["../../../src/lib/mitsubishi/mitsubishiApi.ts"],
  "sourcesContent": ["// src/mitsubishi/mitsubishiApi.ts\r\nimport axios, { AxiosInstance } from \"axios\";\r\nimport * as crypto from \"crypto\";\r\nimport { KEY_SIZE, STATIC_KEY } from \"./types\";\r\nimport { padIso7816, unpadIso7816 } from \"./utils\";\r\n\r\nexport class MitsubishiAPI {\r\n\tprivate log: ioBroker.Logger;\r\n\tprivate deviceHostPort: string;\r\n\tprivate encryptionKey: Buffer;\r\n\tprivate adminUsername: string;\r\n\tprivate adminPassword: string;\r\n\tprivate http: AxiosInstance;\r\n\r\n\tconstructor(\r\n\t\tdeviceHostPort: string,\r\n\t\tlog: ioBroker.Logger,\r\n\t\tencryptionKey: string | Buffer = STATIC_KEY,\r\n\t\tadminUsername = \"admin\",\r\n\t\tadminPassword = \"me1debug@0567\",\r\n\t) {\r\n\t\tthis.deviceHostPort = deviceHostPort;\r\n\t\tthis.log = log;\r\n\t\tif (typeof encryptionKey === \"string\") encryptionKey = Buffer.from(encryptionKey, \"utf8\");\r\n\t\tif (encryptionKey.length < KEY_SIZE) {\r\n\t\t\tencryptionKey = Buffer.concat([encryptionKey, Buffer.alloc(KEY_SIZE - encryptionKey.length, 0x00)]);\r\n\t\t}\r\n\t\tthis.encryptionKey = encryptionKey.subarray(0, KEY_SIZE);\r\n\t\tthis.adminUsername = adminUsername;\r\n\t\tthis.adminPassword = adminPassword;\r\n\r\n\t\t// Axios instance; note Python used requests.Session() + Retry adapter.\r\n\t\t// We'll implement retries in make_request similarly.\r\n\t\tthis.http = axios.create({\r\n\t\t\ttimeout: 2000,\r\n\t\t\theaders: {\r\n\t\t\t\t\"User-Agent\":\r\n\t\t\t\t\t\"KirigamineRemote/5.1.0 (jp.co.MitsubishiElectric.KirigamineRemote; build:3; iOS 17.5.1) Alamofire/5.9.1\",\r\n\t\t\t},\r\n\t\t\t// do not automatically throw for non-2xx; we will call resp.status/raise manually\r\n\t\t\tvalidateStatus: () => true,\r\n\t\t});\r\n\t}\r\n\r\n\tgetCryptoKey(): Buffer {\r\n\t\treturn this.encryptionKey;\r\n\t}\r\n\r\n\tgetDeviceHostPort(): string {\r\n\t\treturn this.deviceHostPort;\r\n\t}\r\n\r\n\t/**\r\n\t * Encrypt payload using AES-CBC with ISO7816-4 padding\r\n\t * Returns base64(iv + ciphertext)\r\n\t */\r\n\tencryptPayload(payload: string, iv?: Buffer): string {\r\n\t\tif (!iv) iv = crypto.randomBytes(KEY_SIZE);\r\n\t\tconst cipher = crypto.createCipheriv(\"aes-128-cbc\", this.encryptionKey, iv);\r\n\t\tcipher.setAutoPadding(false);\r\n\r\n\t\tconst payloadBytes = Buffer.from(payload, \"utf8\");\r\n\t\tconst padded = padIso7816(payloadBytes, KEY_SIZE);\r\n\r\n\t\tconst encrypted = Buffer.concat([cipher.update(padded), cipher.final()]);\r\n\r\n\t\tconst combined = Buffer.concat([iv, encrypted]);\r\n\t\treturn combined.toString(\"base64\");\r\n\t}\r\n\r\n\t/**\r\n\t * Decrypt base64(iv + ciphertext) using AES-CBC + ISO7816 unpad fallback.\r\n\t * Mirrors Python behaviour: try iso7816 unpad; on failure strip trailing \\x00;\r\n\t * then try to decode UTF-8; on UnicodeDecodeError search for closing tags and fallback to ignore errors.\r\n\t */\r\n\tdecryptPayload(payload_b64: string): string {\r\n\t\t// base64 -> bytes\r\n\t\tconst encrypted = Buffer.from(payload_b64, \"base64\"); // may throw\r\n\r\n\t\t// Extract IV and encrypted_data\r\n\t\tconst iv = encrypted.subarray(0, KEY_SIZE);\r\n\t\tconst encrypted_data = encrypted.subarray(KEY_SIZE);\r\n\r\n\t\t// AES-CBC decrypt\r\n\t\tconst decipher = crypto.createDecipheriv(\"aes-128-cbc\", this.encryptionKey, iv);\r\n\t\tdecipher.setAutoPadding(false);\r\n\t\tlet decrypted: Buffer;\r\n\t\ttry {\r\n\t\t\tdecrypted = Buffer.concat([decipher.update(encrypted_data), decipher.final()]);\r\n\t\t} catch (e) {\r\n\t\t\t// Propagate error similar to Python (will be caught higher-level)\r\n\t\t\tthrow new Error(`Decryption failed: ${(e as Error).message}`);\r\n\t\t}\r\n\r\n\t\t// Try ISO7816 unpad\r\n\t\tlet decrypted_clean: Buffer;\r\n\t\ttry {\r\n\t\t\tdecrypted_clean = unpadIso7816(decrypted, KEY_SIZE);\r\n\t\t} catch (e) {\r\n\t\t\t// fallback: remove trailing 0x00\r\n\t\t\tlet end = decrypted.length;\r\n\t\t\twhile (end > 0 && decrypted[end - 1] === 0x00) end--;\r\n\t\t\tdecrypted_clean = decrypted.subarray(0, end);\r\n\t\t}\r\n\r\n\t\t// Try to decode as UTF-8\r\n\t\ttry {\r\n\t\t\tconst result = decrypted_clean.toString(\"utf8\");\r\n\t\t\treturn result;\r\n\t\t} catch (ude) {\r\n\t\t\t// Node's Buffer.toString won't throw UnicodeDecodeError like Python; but we'll follow fallback logic.\r\n\t\t\t// Attempt to find closing tags in raw bytes, then decode slice.\r\n\t\t}\r\n\r\n\t\t// Try to find closing XML tags like Python did\r\n\t\tconst xml_end_patterns = [Buffer.from(\"</LSV>\"), Buffer.from(\"</CSV>\"), Buffer.from(\"</ESV>\")];\r\n\t\tfor (const pattern of xml_end_patterns) {\r\n\t\t\tconst pos = decrypted_clean.indexOf(pattern);\r\n\t\t\tif (pos !== -1) {\r\n\t\t\t\tconst end_pos = pos + pattern.length;\r\n\t\t\t\tconst truncated = decrypted_clean.subarray(0, end_pos);\r\n\t\t\t\ttry {\r\n\t\t\t\t\treturn truncated.toString(\"utf8\");\r\n\t\t\t\t} catch {\r\n\t\t\t\t\t// continue\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Last resort: decode ignoring errors (in Node Buffer.toString does not have errors='ignore' param,\r\n\t\t// but replacing invalid sequences is default behaviour; to mimic 'ignore' we can remove replacement characters)\r\n\t\t// We'll return decoded string (replacement characters may appear).\r\n\t\tconst fallback_result = decrypted_clean.toString(\"utf8\");\r\n\t\treturn fallback_result;\r\n\t}\r\n\r\n\t/**\r\n\t * Make HTTP request to /smart endpoint.\r\n\t * Mirrors Python's make_request: encrypt payload, wrap in <ESV>..</ESV>, POST, parse response, decrypt.\r\n\t */\r\n\tasync makeRequest(payload_xml: string): Promise<string> {\r\n\t\t// Encrypt\r\n\t\tconst encrypted_payload = this.encryptPayload(payload_xml);\r\n\r\n\t\t// Build request body (exact same string shape)\r\n\t\tconst request_body = `<?xml version=\"1.0\" encoding=\"UTF-8\"?><ESV>${encrypted_payload}</ESV>`;\r\n\r\n\t\tconst headers = {\r\n\t\t\tHost: `${this.deviceHostPort}`,\r\n\t\t\t\"Content-Type\": \"text/plain;chrset=UTF-8\",\r\n\t\t\tConnection: \"keep-alive\",\r\n\t\t\t\"Proxy-Connection\": \"keep-alive\",\r\n\t\t\tAccept: \"*/*\",\r\n\t\t\t\"User-Agent\":\r\n\t\t\t\t\"KirigamineRemote/5.1.0 (jp.co.MitsubishiElectric.KirigamineRemote; build:3; iOS 17.5.1) Alamofire/5.9.1\",\r\n\t\t\t\"Accept-Language\": \"zh-Hant-JP;q=1.0, ja-JP;q=0.9\",\r\n\t\t};\r\n\r\n\t\tconst url = `http://${this.deviceHostPort}/smart`;\r\n\r\n\t\t// retry logic: total=4, backoff_factor=1 (attempts 0..4)\r\n\t\tconst maxRetries = 4;\r\n\t\tlet lastErr: any = null;\r\n\t\tfor (let attempt = 0; attempt <= maxRetries; attempt++) {\r\n\t\t\ttry {\r\n\t\t\t\tconst resp = await this.http.post(url, request_body, { headers, timeout: 2000 });\r\n\t\t\t\t// emulate response.raise_for_status()\r\n\t\t\t\tif (resp.status < 200 || resp.status >= 300) {\r\n\t\t\t\t\tconst e = new Error(`HTTP Error ${resp.status}`);\r\n\t\t\t\t\t(e as any).status = resp.status;\r\n\t\t\t\t\t(e as any).body = resp.data;\r\n\t\t\t\t\tthrow e;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Parse XML root and get root.text like ElementTree.fromstring(...).text\r\n\t\t\t\t// Python: root = ET.fromstring(response.text); encrypted_response = root.text\r\n\t\t\t\t// Here extract inner text between the outermost tag, e.g. <ESV>...</ESV>\r\n\t\t\t\tconst m = String(resp.data).match(/<ESV>\\s*([^<]+)\\s*<\\/ESV>/i);\r\n\t\t\t\tconst encrypted_response = m?.[1];\r\n\r\n\t\t\t\tif (encrypted_response) {\r\n\t\t\t\t\tif (encrypted_response.length % 4 !== 0) {\r\n\t\t\t\t\t\tthis.log.error(`Invalid base64 length: ${encrypted_response.length}`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst decrypted = this.decryptPayload(encrypted_response);\r\n\t\t\t\t\treturn decrypted;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new Error(\"Could not find any text in response\");\r\n\t\t\t\t}\r\n\t\t\t} catch (err) {\r\n\t\t\t\tlastErr = err;\r\n\t\t\t\tif (attempt < maxRetries) {\r\n\t\t\t\t\tconst wait = 1000 * Math.pow(2, attempt); // backoff_factor=1 -> 1s,2s,4s...\r\n\t\t\t\t\tawait new Promise(r => setTimeout(r, wait));\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tthrow lastErr;\r\n\t\t\t}\r\n\t\t}\r\n\t\tthrow lastErr;\r\n\t}\r\n\r\n\tsendRebootRequest(): Promise<string> {\r\n\t\treturn this.makeRequest(\"<CSV><RESET></RESET></CSV>\");\r\n\t}\r\n\r\n\tsendStatusRequest(): Promise<string> {\r\n\t\treturn this.makeRequest(\"<CSV><CONNECT>ON</CONNECT></CSV>\");\r\n\t}\r\n\r\n\tsendEchonetEnable(): Promise<string> {\r\n\t\treturn this.makeRequest(\"<CSV><CONNECT>ON</CONNECT><ECHONET>ON</ECHONET></CSV>\");\r\n\t}\r\n\r\n\tsendCommand(command: Buffer | Uint8Array): Promise<string> {\r\n\t\tconst hex = Buffer.isBuffer(command) ? command.toString(\"hex\") : Buffer.from(command).toString(\"hex\");\r\n\t\treturn this.sendHexCommand(hex);\r\n\t}\r\n\r\n\tsendHexCommand(hexCommand: string): Promise<string> {\r\n\t\tconst payload = `<CSV><CONNECT>ON</CONNECT><CODE><VALUE>${hexCommand}</VALUE></CODE></CSV>`;\r\n\t\treturn this.makeRequest(payload);\r\n\t}\r\n\r\n\tasync getUnitInfo(): Promise<Record<string, Record<string, string>>> {\r\n\t\tconst url = `http://${this.deviceHostPort}/unitinfo`;\r\n\t\tconst resp = await this.http.get(url, {\r\n\t\t\tauth: {\r\n\t\t\t\tusername: this.adminUsername,\r\n\t\t\t\tpassword: this.adminPassword,\r\n\t\t\t},\r\n\t\t\ttimeout: 2000,\r\n\t\t});\r\n\t\treturn this.parseUnitInfoHtml(resp.data);\r\n\t}\r\n\r\n\tprivate parseUnitInfoHtml(html: string): Record<string, Record<string, string>> {\r\n\t\tconst unitInfo: Record<string, Record<string, string>> = {};\r\n\t\tconst titleRegex = /<div[^>]*class=[\"']titleA[\"'][^>]*>([^<]+)<\\/div>/gi;\r\n\t\tconst dtDdRegex = /<dt>([^<]+)<\\/dt>\\s*<dd>([^<]+)<\\/dd>/gi;\r\n\r\n\t\tconst sections: { name: string; index: number }[] = [];\r\n\t\tlet match: RegExpExecArray | null;\r\n\t\twhile ((match = titleRegex.exec(html)) !== null) {\r\n\t\t\tsections.push({ name: match[1].trim(), index: match.index });\r\n\t\t}\r\n\r\n\t\tif (sections.length === 0) {\r\n\t\t\tunitInfo[\"Unit Info\"] = {};\r\n\t\t\tlet m;\r\n\t\t\twhile ((m = dtDdRegex.exec(html)) !== null) {\r\n\t\t\t\tunitInfo[\"Unit Info\"][m[1].trim()] = m[2].trim();\r\n\t\t\t}\r\n\t\t\treturn unitInfo;\r\n\t\t}\r\n\r\n\t\tfor (let i = 0; i < sections.length; i++) {\r\n\t\t\tconst name = sections[i].name;\r\n\t\t\tconst start = sections[i].index;\r\n\t\t\tconst end = i + 1 < sections.length ? sections[i + 1].index : html.length;\r\n\t\t\tconst segment = html.slice(start, end);\r\n\t\t\tunitInfo[name] = {};\r\n\t\t\tlet m;\r\n\t\t\twhile ((m = dtDdRegex.exec(segment)) !== null) {\r\n\t\t\t\tunitInfo[name][m[1].trim()] = m[2].trim();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// try casting Channel and RSSI like python\r\n\t\ttry {\r\n\t\t\tif (unitInfo[\"Adaptor Information\"] && unitInfo[\"Adaptor Information\"][\"Channel\"]) {\r\n\t\t\t\tunitInfo[\"Adaptor Information\"][\"Channel\"] = String(\r\n\t\t\t\t\tparseInt(unitInfo[\"Adaptor Information\"][\"Channel\"], 10),\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t} catch {}\r\n\t\ttry {\r\n\t\t\tif (unitInfo[\"Adaptor Information\"] && unitInfo[\"Adaptor Information\"][\"RSSI\"]) {\r\n\t\t\t\tunitInfo[\"Adaptor Information\"][\"RSSI\"] = String(\r\n\t\t\t\t\tparseFloat(unitInfo[\"Adaptor Information\"][\"RSSI\"].replace(\"dBm\", \"\").trim()),\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t} catch {}\r\n\r\n\t\treturn unitInfo;\r\n\t}\r\n\r\n\tclose(): void {\r\n\t\t// nothing to close; keep for API parity\r\n\t\t(this.http as any) = null;\r\n\t}\r\n}\r\n"],
  "mappings": "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",
  "names": ["axios"]
}
