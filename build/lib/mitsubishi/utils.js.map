{
  "version": 3,
  "sources": ["../../../src/lib/mitsubishi/utils.ts"],
  "sourcesContent": ["import { KEY_SIZE } from \"./types\";\n\nexport function padIso7816(input: Buffer, blockSize = KEY_SIZE): Buffer {\n\t// Python's Crypto.Util.Padding.pad(..., \"iso7816\")\n\tconst padLen = blockSize - (input.length % blockSize);\n\tconst out = Buffer.alloc(input.length + padLen);\n\tinput.copy(out, 0);\n\tout[input.length] = 0x80;\n\t// the rest are 0x00 already\n\treturn out;\n}\n\nexport function unpadIso7816(padded: Buffer): Buffer {\n\t// Remove ISO 7816-4 padding: find last 0x80 and cut there, else throw\n\tlet i = padded.length - 1;\n\t// strip trailing 0x00\n\twhile (i >= 0 && padded[i] === 0x00) {\n\t\ti--;\n\t}\n\tif (i < 0 || padded[i] !== 0x80) {\n\t\tthrow new Error(\"Invalid ISO7816 padding\");\n\t}\n\treturn padded.subarray(0, i);\n}\n\n/** calc FCC as in Python: 0x100 - (sum(payload[0:20]) % 0x100)  then mod 0x100 */\nexport function calcFcc(payload: Buffer): number {\n\tconst slice = payload.subarray(0, 20);\n\tconst sum = slice.reduce((s, b) => s + b, 0);\n\treturn (0x100 - (sum % 0x100)) % 0x100;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAyB;AAElB,SAAS,WAAW,OAAe,YAAY,uBAAkB;AAEvE,QAAM,SAAS,YAAa,MAAM,SAAS;AAC3C,QAAM,MAAM,OAAO,MAAM,MAAM,SAAS,MAAM;AAC9C,QAAM,KAAK,KAAK,CAAC;AACjB,MAAI,MAAM,MAAM,IAAI;AAEpB,SAAO;AACR;AAEO,SAAS,aAAa,QAAwB;AAEpD,MAAI,IAAI,OAAO,SAAS;AAExB,SAAO,KAAK,KAAK,OAAO,CAAC,MAAM,GAAM;AACpC;AAAA,EACD;AACA,MAAI,IAAI,KAAK,OAAO,CAAC,MAAM,KAAM;AAChC,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC1C;AACA,SAAO,OAAO,SAAS,GAAG,CAAC;AAC5B;AAGO,SAAS,QAAQ,SAAyB;AAChD,QAAM,QAAQ,QAAQ,SAAS,GAAG,EAAE;AACpC,QAAM,MAAM,MAAM,OAAO,CAAC,GAAG,MAAM,IAAI,GAAG,CAAC;AAC3C,UAAQ,MAAS,MAAM,OAAU;AAClC;",
  "names": []
}
