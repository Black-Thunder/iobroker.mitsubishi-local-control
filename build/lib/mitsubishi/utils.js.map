{
  "version": 3,
  "sources": ["../../../src/lib/mitsubishi/utils.ts"],
  "sourcesContent": ["import { KEY_SIZE } from \"./types\";\n\nexport function padIso7816(input: Buffer, blockSize = KEY_SIZE): Buffer {\n\t// Python's Crypto.Util.Padding.pad(..., \"iso7816\")\n\tconst padLen = blockSize - (input.length % blockSize);\n\tconst out = Buffer.alloc(input.length + padLen);\n\tinput.copy(out, 0);\n\tout[input.length] = 0x80;\n\t// the rest are 0x00 already\n\treturn out;\n}\n\nexport function unpadIso7816(padded: Buffer): Buffer {\n\t// Remove ISO 7816-4 padding: find last 0x80 and cut there, else throw\n\tlet i = padded.length - 1;\n\t// strip trailing 0x00\n\twhile (i >= 0 && padded[i] === 0x00) {\n\t\ti--;\n\t}\n\tif (i < 0 || padded[i] !== 0x80) {\n\t\tthrow new Error(\"Invalid ISO7816 padding\");\n\t}\n\treturn padded.subarray(0, i);\n}\n\n/** calc FCC as in Python: 0x100 - (sum(payload[0:20]) % 0x100)  then mod 0x100 */\nexport function calcFcc(payload: Buffer): number {\n\tconst slice = payload.subarray(0, 20);\n\tconst sum = slice.reduce((s, b) => s + b, 0);\n\treturn (0x100 - (sum % 0x100)) % 0x100;\n}\n\nexport function getMacFromStateId(id: string): string | null {\n\tconst parts = id.split(\".\");\n\tconst idx = parts.indexOf(\"devices\");\n\n\tif (idx >= 0 && parts.length > idx + 1) {\n\t\treturn parts[idx + 1]; // das ist die MAC\n\t}\n\n\treturn null;\n}\n\nexport function isValidIPv4(ip: string): boolean {\n\t// Basic structural check (4 octets, only digits)\n\tconst parts = ip.split(\".\");\n\tif (parts.length !== 4) {\n\t\treturn false;\n\t}\n\n\tfor (const part of parts) {\n\t\t// Reject empty, non-numeric or leading zeros like \"01\"\n\t\tif (!/^\\d{1,3}$/.test(part)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst num = Number(part);\n\t\tif (num < 0 || num > 255) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nexport function enumToStates(enumObj: any): Record<string, string> {\n\tconst res: Record<string, string> = {};\n\tfor (const key of Object.keys(enumObj)) {\n\t\tconst v = enumObj[key];\n\t\tif (typeof v === \"number\") {\n\t\t\tres[v] = enumName(enumObj, v) ?? key;\n\t\t}\n\t}\n\treturn res;\n}\n\nexport function isEnumValue(enumObj: any, value: number): boolean {\n\treturn Object.values(enumObj).includes(value);\n}\n\nexport function enumName(enumObj: any, value: number): string {\n\treturn enumObj[value] ?? value.toString();\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAyB;AAElB,SAAS,WAAW,OAAe,YAAY,uBAAkB;AAEvE,QAAM,SAAS,YAAa,MAAM,SAAS;AAC3C,QAAM,MAAM,OAAO,MAAM,MAAM,SAAS,MAAM;AAC9C,QAAM,KAAK,KAAK,CAAC;AACjB,MAAI,MAAM,MAAM,IAAI;AAEpB,SAAO;AACR;AAEO,SAAS,aAAa,QAAwB;AAEpD,MAAI,IAAI,OAAO,SAAS;AAExB,SAAO,KAAK,KAAK,OAAO,CAAC,MAAM,GAAM;AACpC;AAAA,EACD;AACA,MAAI,IAAI,KAAK,OAAO,CAAC,MAAM,KAAM;AAChC,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC1C;AACA,SAAO,OAAO,SAAS,GAAG,CAAC;AAC5B;AAGO,SAAS,QAAQ,SAAyB;AAChD,QAAM,QAAQ,QAAQ,SAAS,GAAG,EAAE;AACpC,QAAM,MAAM,MAAM,OAAO,CAAC,GAAG,MAAM,IAAI,GAAG,CAAC;AAC3C,UAAQ,MAAS,MAAM,OAAU;AAClC;AAEO,SAAS,kBAAkB,IAA2B;AAC5D,QAAM,QAAQ,GAAG,MAAM,GAAG;AAC1B,QAAM,MAAM,MAAM,QAAQ,SAAS;AAEnC,MAAI,OAAO,KAAK,MAAM,SAAS,MAAM,GAAG;AACvC,WAAO,MAAM,MAAM,CAAC;AAAA,EACrB;AAEA,SAAO;AACR;AAEO,SAAS,YAAY,IAAqB;AAEhD,QAAM,QAAQ,GAAG,MAAM,GAAG;AAC1B,MAAI,MAAM,WAAW,GAAG;AACvB,WAAO;AAAA,EACR;AAEA,aAAW,QAAQ,OAAO;AAEzB,QAAI,CAAC,YAAY,KAAK,IAAI,GAAG;AAC5B,aAAO;AAAA,IACR;AAEA,UAAM,MAAM,OAAO,IAAI;AACvB,QAAI,MAAM,KAAK,MAAM,KAAK;AACzB,aAAO;AAAA,IACR;AAAA,EACD;AAEA,SAAO;AACR;AAEO,SAAS,aAAa,SAAsC;AAjEnE;AAkEC,QAAM,MAA8B,CAAC;AACrC,aAAW,OAAO,OAAO,KAAK,OAAO,GAAG;AACvC,UAAM,IAAI,QAAQ,GAAG;AACrB,QAAI,OAAO,MAAM,UAAU;AAC1B,UAAI,CAAC,KAAI,cAAS,SAAS,CAAC,MAAnB,YAAwB;AAAA,IAClC;AAAA,EACD;AACA,SAAO;AACR;AAEO,SAAS,YAAY,SAAc,OAAwB;AACjE,SAAO,OAAO,OAAO,OAAO,EAAE,SAAS,KAAK;AAC7C;AAEO,SAAS,SAAS,SAAc,OAAuB;AAhF9D;AAiFC,UAAO,aAAQ,KAAK,MAAb,YAAkB,MAAM,SAAS;AACzC;",
  "names": []
}
